#!/usr/bin/python

# TODOS:
#  - allow DynamoDB to be used as a meta-data service
#  - encrypt etcd usage
#  - add tests!

from __future__ import print_function
import argparse
import os
import sys
import signal
import time
import subprocess
import socket

import urllib
import requests
import boto3
import json





class Toolkit(object):
    """docstring for Toolkit"""

    def __init__(self, config):
        super(Toolkit, self).__init__()
        self.config = config


    def monitor_response(self):
        try:
            return requests.get(self.config.monitor_url)
        except (requests.exceptions.Timeout, socket.timeout, requests.exceptions.ConnectionError):
            # Maybe set up for a retry, or continue in a retry loop
            r = requests.Response()
            r.status_code = 408
            return r


    def unregister_service(self):
        requests.delete(self.config.etcd_service_key_url())


    def register_service(self):
        etcd_service_value   = '{"name": "%s", "host": "%s"}' % (self.config.service_id, self.config.host_ip)
        requests.put(self.config.etcd_service_key_url(), {'value':etcd_service_value, 'ttl':30} )


    def acquire_lease(self, scope=''):
        timeout = time.time() + self.config.acquire_timeout
        while time.time() < timeout:
            response = requests.put(self.config.etcd_lock_url(scope) + "?prevExist=false", {'value': self.config.service_id, 'ttl':self.config.lease_timeout} )
            if response.ok:
                return True
            time.sleep(1)
        return False


    def release_lease(self, scope=''):
        return requests.delete(self.config.etcd_lock_url(scope) + '?prevValue={0}'.format(urllib.quote_plus(self.config.service_id)))


    def retrieve_certs(self):
        response = requests.get(self.config.etcd_cert_keys_url() + '?consistent=true')
        if response.ok:
            response.encoding = 'UTF-8'
            json = response.json()
            if 'nodes' in json['node']:
                private_key = (item for item in json['node']['nodes'] if item["key"] == "/certs/{0}/x509_private_key".format(self.config.label)).next()['value']
                cert        = (item for item in json['node']['nodes'] if item["key"] == "/certs/{0}/x509_certificate".format(self.config.label)).next()['value']
                return {'key': private_key, 'cert': cert, 'type': 'x509'}
        return None


    def create_x509_certs(self):
        try:
            if self.acquire_lease('x509'):
                certs = self.retrieve_certs()
                if certs:
                    return certs 
                key_filename  = "/tmp/{0}.key".format(self.config.label)
                cert_filename = "/tmp/{0}.crt".format(self.config.label)
                os.system("openssl req -x509 -batch -nodes -newkey rsa:4096 -keyout {0} -out {1} 2>/dev/null".format(key_filename, cert_filename))
                private_key = open(key_filename,'r').read()
                cert        = open(cert_filename,'r').read()
                requests.put("{0}x509_private_key".format(self.config.etcd_cert_keys_url()), {'value': private_key} )
                requests.put("{0}x509_certificate".format(self.config.etcd_cert_keys_url()), {'value': cert} )
                # requests.put(self.config.etcd_service_key_url(), {'value':etcd_service_value, 'ttl':30} )

                return {'key': private_key, 'cert': cert, 'type': 'x509'}
            else:
                return None
        finally:
            self.release_lease('x509')


    def hosts(self):
        response = requests.get(config.etcd_service_hosts_url() + '?recursive=true&consistent=true')
        response.encoding = 'UTF-8'
        json = response.json()
        output=[]
        if response.ok and 'nodes' in json['node']:
            for i, node in enumerate(json['node']['nodes']):
                output.append(node['key'].replace(self.config.etcd_service_hosts_path(), ''))

        return output




class Config(object):

    def __init__(self, args):
        super(Config, self).__init__()
        self.__dict__.update(vars(args))
        self.label = self.label.lower()
        process    = subprocess.Popen("ip route show 0.0.0.0/0 | grep -Eo 'via \S+' | awk '{ print $2 }'", stdout=subprocess.PIPE, shell=True)
        if not self.host_ip:
            # lets try docker way
            process = subprocess.Popen("ip address show docker0 2>/dev/null | grep 'inet ' | awk '{gsub(/\/[0-9]{2}/, \"\"); print $2}'", stdout=subprocess.PIPE, shell=True)
            self.host_ip = process.stdout.read().strip()
        if not self.host_ip:
            # lets try general IP way
            process = subprocess.Popen("ip route show 0.0.0.0/0 | grep -Eo 'via \S+' | awk '{ print $2 }'", stdout=subprocess.PIPE, shell=True)
            self.host_ip = process.stdout.read().strip()


    def etcd_lock_url(self, scope=''):
        url = '{0}/locks/'.format(self.etcd_base_url(), self.label)
        if scope:
            url += '{0}_{1}/'.format(scope, self.label)
        else:
            url += '{0}/'.format(self.label)
        return url


    def etcd_base_url(self):
        return 'http://{0}:4001/v2/keys'.format(self.host_ip)


    def etcd_service_hosts_path(self):
        return '/services/{0}/hosts/'.format(self.label)


    def etcd_service_hosts_url(self):
        return '{0}{1}'.format(self.etcd_base_url(), self.etcd_service_hosts_path())


    def etcd_service_key_url(self):
        return '{0}/{1}'.format(self.etcd_service_hosts_url(), self.host_ip)


    def etcd_cert_keys_url(self):
        return '{0}/certs/{1}/'.format(self.etcd_base_url(), self.label)




class Util(object):
        
    @classmethod
    def print_msg(cls, message, file=sys.stdout):
        # os.system('systemd-cat -t "[{0}]" echo "{1}"'.format(args.label, message))
        print("[{0}] {1}".format(args.label, message), file=file)


    @classmethod
    def handle_exception(cls, e):
        # catastrophic error. bail.
        Util.print_msg(type(e))
        Util.print_msg(e)
        Util.print_msg(traceback.format_exc())

    @classmethod
    def parse_inputs(cls):
        parser = argparse.ArgumentParser(description='Help manage services, such as register in a discovery service, setup security certificates, and monitor a service')
        subparsers = parser.add_subparsers(dest='cmd')#(title='my title', description='my description', help='my help')

        # A watch command
        watch_parser = subparsers.add_parser('watch', help='watch for changes')
        watch_parser.set_defaults(func=watch)
        watch_parser.add_argument('--label', metavar='<LABEL>', required=True, help='General label of the Service to monitor.')
        watch_parser.add_argument('--service-id', metavar='<SERVICE-ID>', required=True, help='The specific id of the service to monitor.')
        watch_parser.add_argument('--monitor-url', metavar='<MONITOR-URL>', required=True,
                            help='The URL to call to monitor the external process.  You can use an internally or ' + 
                                 'externally available URL, such as "http://172.17.8.101:9200", or one from a ' + 
                                 'linked container such as "http://service:9200".')
        watch_parser.add_argument('--service-info', metavar='<SERVICE-INFO>', help='If nothing is added, defaults to "{"name": "<SERVICE-ID>"}".')

        # An aquire-lease command
        lease_parser = subparsers.add_parser('acquire-lease', help='Acquire a lease to start monitoring')
        lease_parser.set_defaults(func=acquire_lease)
        lease_parser.add_argument('--label', metavar='<LABEL>',           required=True, help='General label of the Service to monitor.')
        lease_parser.add_argument('--service-id', metavar='<SERVICE-ID>', required=True, help='The specific id of the service to monitor.')
        lease_parser.add_argument('--lease-timeout', metavar='<LEASE-TIMEOUT>',     type=int, help='How long until the lease expires', default=240)
        lease_parser.add_argument('--acquire-timeout', metavar='<ACQUIRE-TIMEOUT>', type=int, help='How long to wait for a lease to become available', default=360)

        # A hosts command
        host_parser = subparsers.add_parser('hosts', help='list hosts')
        host_parser.set_defaults(func=hosts)
        host_parser.add_argument('--label', metavar='<LABEL>', required=True, help='General label of the Service to monitor.')
        host_parser.add_argument('--wait', action='store_true', help='wait until there is at least one host returned.')

        # A cert command
        cert_parser = subparsers.add_parser('cert', help='retrieve security certificate')
        cert_parser.set_defaults(func=cert)
        cert_parser.add_argument('--label', metavar='<LABEL>', required=True, help='General label of the Service to monitor.')
        cert_parser.add_argument('--service-id', metavar='<SERVICE-ID>', required=True, help='The specific id of the service to monitor.')
        cert_parser.add_argument('--x509', action='store_true')
        cert_parser.add_argument('--lease-timeout', metavar='<LEASE-TIMEOUT>', type=int, help='How long until the lease expires', default=240)
        cert_parser.add_argument('--acquire-timeout', metavar='<ACQUIRE-TIMEOUT>', type=int, help='How long until the lease expires', default=360)

        # #add common and OPTIONAL arguments
        for title, subparser in subparsers.choices.iteritems():
            subparser.add_argument('--backend', metavar='<BACKEND>', choices=['etcd', 'DynamoDB'])
            subparser.add_argument('--host-ip', metavar='<HOST_IP>', help='set the host_ip rather than the script guessing.')

        args = parser.parse_args()
        return args




def unregister_service(signum=None, frame=None):
    Util.print_msg("Watching {0} has been stopped".format(config.service_id))
    toolkit.unregister_service()
    sys.exit(0)


def acquire_lease(args):
    Util.print_msg("Waiting to acquire lease")
    response = toolkit.acquire_lease()
    if response:
        Util.print_msg("Acquired lease")
        sys.exit(0)
    else:
        Util.print_msg("timed out waiting to acquire lease")
        sys.exit(1)


def watch(args):
    Util.print_msg("Starting to watch")
    lease_released = False
    try:
        while True:
            if toolkit.monitor_response().ok:
                toolkit.register_service()
                Util.print_msg("Instance is up")
                if lease_released is False:
                    response = toolkit.release_lease()
                    if response.ok:
                        Util.print_msg("Releasing acquire lock")
                        lease_released=True
            else:
                toolkit.unregister_service()
                Util.print_msg("Instance {0} is not running and has been unregistered".format(config.service_id))

            time.sleep(20)
    except Exception as e:
        # catastrophic error. bail.
        Util.handle_exception(e)
        sys.exit(1)


def hosts(args):
    try:
        while True:
            hosts = toolkit.hosts()
            if hosts:
                print( ','.join(str(x) for x in hosts) )
                sys.exit(0)
            elif not args.wait
                sys.exit(1)

    except Exception as e:
        # catastrophic error. bail.
        Util.handle_exception(e)
        sys.exit(1)



def cert(args):
    try:
        certs = toolkit.retrieve_certs()
        if not certs:
            if config.x509:
                certs = toolkit.create_x509_certs()
                if not certs:
                    #timed out with no luck!  exit
                    Util.print_msg("lease was not available!")
                    sys.exit(1)
            else:
                #don't know what to do!
                Util.print_msg("security method not defined!  Exiting")
                return {}
        if certs:
            print(json.dumps(certs))
            return
    except Exception as e:
        # catastrophic error. bail.
        Util.handle_exception(e)
        sys.exit(1)



############################################################################
## Run
############################################################################
# lets setup stdout to not have any write buffer
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)

# lets handle unix signals
signal.signal(signal.SIGTERM, unregister_service)
signal.signal(signal.SIGINT,  unregister_service)


args    = Util.parse_inputs()
config = Config(args)
toolkit = Toolkit(config)

#trigger the assigned function call!
args.func(args) 



# service-toolkit cert --label=logstash --x509
# --name=ElasticSearch_Logging
# --instance_id=es_logging-1
# --lock-ttl=240
# --monitor-url=localhost:9200
# --etcd-key=/services/elasticsearch_logging/hosts/172.17.8.101
# --etcd-value='{"http_port": 9200, "transport_port": 9300, "name": "ElasticSearch_Logging-1"}'
# --docker

# docker run --rm -it --link elasticsearch_logging-1:service ubuntu:14.10 /bin/bash
# curl http://service:9200

# ip route show 0.0.0.0/0 | grep -Eo 'via \S+' | awk '{ print $2 }'
# ip route get 1.1.1.1 | grep -Eo 'via \S+' | awk '{ print $2 }'
# netstat -nr | grep '^0\.0\.0\.0' | awk '{print $2}'
