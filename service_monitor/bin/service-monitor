#!/usr/bin/python

# TODOS:
#  - allow DynamoDB to be used as a meta-data service
#  - encrypt etcd usage
#  - add tests!
#  - make more OO friendly

import argparse
import os
import sys
import signal
import time
import subprocess
import socket

import urllib
import requests
import boto3


def print_msg(message):
    # os.system('systemd-cat -t "[{0}]" echo "{1}"'.format(args.label, message))
    print("[{0}] {1}".format(args.label, message))


def monitor_response():
    try:
        return requests.get(args.monitor_url)
    except (requests.exceptions.Timeout, socket.timeout, requests.exceptions.ConnectionError):
        # Maybe set up for a retry, or continue in a retry loop
        r = requests.Response()
        r.status_code = 408
        return r
    except requests.exceptions.RequestException as e:
        # catastrophic error. bail.
        print_msg(type(e))
        print_msg(e)
        sys.exit(1)


def unregister_service():
    requests.delete(etcd_service_key)


def unregister_service_handler(signum=None, frame=None):
    print_msg("Watching {0} has been stopped".format(args.service_id))
    unregister_service()
    sys.exit(0)


def register_service():
    etcd_service_value   = '{"name": "%s"}' % (args.service_id)
    requests.put(etcd_service_key, {'value':etcd_service_value, 'ttl':30} )
    print_msg("Instance {0} is up".format(args.service_id))



def acquire_lease(args):
    print_msg("Waiting to acquire lease")
    timeout = time.time() + args.acquire_timeout
    while time.time() < timeout:
        response = requests.put(etcd_lock_url + "?prevExist=false", {'value': args.service_id, 'ttl':args.lease_timeout} )
        if response.ok:
            print_msg("Acquired lease")
            sys.exit(0)
        time.sleep(2)

    print_msg("timed out waiting to acquire lease")
    sys.exit(1)



def release_lease():
    global lease_released
    if lease_released is False:
        response = requests.delete(etcd_lock_url + '?prevValue={0}'.format(urllib.quote_plus(args.service_id)))
        if response.ok:
            print_msg("Releasing acquire lock")
        lease_released=True


def watch(args):
    print_msg("Starting to watch")
    while True:
        if monitor_response().ok:
            register_service()
            release_lease()
        else:
            print_msg("Instance {0} is not up and has been unregistered".format(args.service_id))
            unregister_service()

        time.sleep(20)


def hosts(args):
    response = requests.get(etcd_service_hosts + '?recursive=true')
    # response = requests.get('http://172.17.8.103:4001/v2/keys/services/elasticsearch_logging/hosts?recursive=true')
    response.encoding = 'UTF-8'
    json = response.json
    output=[]
    if 'node' in json and 'nodes' in json['node']:
        for i, node in enumerate(json['node']['nodes']):
            output.append(node['key'].replace('/services/elasticsearch_logging/hosts/', ''))
        print ','.join(str(x) for x in output)
        exit(0)
    else: 
        exit(1)


############################################################################
## Parse Arguments
############################################################################
parser = argparse.ArgumentParser(description='Register the locally running service with ETCD, and monitor status')

subparsers = parser.add_subparsers(dest='cmd')#(title='my title', description='my description', help='my help')

# A watch command
watch_parser = subparsers.add_parser('watch', help='watch for changes')
watch_parser.set_defaults(func=watch)
watch_parser.add_argument('--label', metavar='<LABEL>', required=True, help='General label of the Service to monitor.')
watch_parser.add_argument('--service-id', metavar='<SERVICE-ID>', required=True, help='The specific id of the service to monitor.')
watch_parser.add_argument('--monitor-url', metavar='<MONITOR-URL>', required=True,
                    help='The URL to call to monitor the external process.  You can use an internally or ' + 
                         'externally available URL, such as "http://172.17.8.101:9200", or one from a ' + 
                         'linked container such as "http://service:9200".')
watch_parser.add_argument('--service-info', metavar='<SERVICE-INFO>', help='If nothing is added, defaults to "{"name": "<SERVICE-ID>"}".')

# An aquire-lease command
lease_parser = subparsers.add_parser('acquire-lease', help='Acquire a lease to start monitoring')
lease_parser.set_defaults(func=acquire_lease)
lease_parser.add_argument('--label', metavar='<LABEL>', required=True, help='General label of the Service to monitor.')
lease_parser.add_argument('--service-id', metavar='<SERVICE-ID>', required=True, help='The specific id of the service to monitor.')
lease_parser.add_argument('--lease-timeout', metavar='<LEASE-TIMEOUT>', type=int, help='How long until the lease expires', default=240)
lease_parser.add_argument('--acquire-timeout', metavar='<ACQUIRE-TIMEOUT>', type=int, help='How long until the lease expires', default=360)

# A hosts command
host_parser = subparsers.add_parser('hosts', help='list hosts')
host_parser.set_defaults(func=hosts)
host_parser.add_argument('--label', metavar='<LABEL>', required=True, help='General label of the Service to monitor.')

# #add common and OPTIONAL arguments
for title, subparser in subparsers.choices.iteritems():
    subparser.add_argument('--backend', metavar='<BACKEND>', choices=['etcd', 'DynamoDB'])
    subparser.add_argument('--host-ip', metavar='<HOST_IP>', help='set the host_ip rather than trying to figure it out from `ip route` or `ip address`')


args = parser.parse_args()
############################################################################
## Setup
############################################################################
process       = subprocess.Popen("ip route show 0.0.0.0/0 | grep -Eo 'via \S+' | awk '{ print $2 }'", stdout=subprocess.PIPE, shell=True)
host_ip       = args.host_ip
if not host_ip:
    # lets try docker way
    process = subprocess.Popen("ip address show docker0 2>/dev/null | grep 'inet ' | awk '{gsub(/\/[0-9]{2}/, \"\"); print $2}'", stdout=subprocess.PIPE, shell=True)
    host_ip = process.stdout.read().strip()
if not host_ip:
    # lets try general IP way
    process = subprocess.Popen("ip route show 0.0.0.0/0 | grep -Eo 'via \S+' | awk '{ print $2 }'", stdout=subprocess.PIPE, shell=True)
    host_ip = process.stdout.read().strip()

etcd_base_url = 'http://{0}:4001/v2/keys'.format(host_ip)
etcd_lock_url = '{0}/locks/{1}/'.format(etcd_base_url, args.label.lower())
etcd_service_hosts = '{0}/services/{1}/hosts'.format(etcd_base_url, args.label.lower())
etcd_service_key   = '{0}/{1}'.format(etcd_service_hosts, host_ip)
lease_released      = False

# lets setup stdout to not have any write buffer
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)

# lets handle unix signals
signal.signal(signal.SIGTERM, unregister_service_handler)
signal.signal(signal.SIGINT,  unregister_service_handler)

# lets trigger the function call!
args.func(args)



############################################################################
## Run
############################################################################



# --name=ElasticSearch_Logging
# --instance_id=es_logging-1
# --lock-ttl=240
# --monitor-url=localhost:9200
# --etcd-key=/services/elasticsearch_logging/hosts/172.17.8.101
# --etcd-value='{"http_port": 9200, "transport_port": 9300, "name": "ElasticSearch_Logging-1"}'
# --docker

# docker run --rm -it --link elasticsearch_logging-1:service ubuntu:14.10 /bin/bash
# curl http://service:9200

# ip route show 0.0.0.0/0 | grep -Eo 'via \S+' | awk '{ print $2 }'
# ip route get 1.1.1.1 | grep -Eo 'via \S+' | awk '{ print $2 }'
# netstat -nr | grep '^0\.0\.0\.0' | awk '{print $2}'
